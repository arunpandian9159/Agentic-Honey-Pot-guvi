{
  "version": "2",
  "formats": {
    "markdown": {
      "content": "## Page 1\n\n# Honeypot API Evaluation System Documentation\n\n## Overview\n\nThis document explains how your submitted Honeypot API will be evaluated in the hackathon. The evaluation system tests your API's ability to detect scams, extract intelligence, and engage with scammers across multiple realistic scenarios.\n\n## Platform Submission Process\n\n### How to Submit Your API\n\nFollow these steps to submit your solution on the hackathon platform:\n\n**Step 1: Navigate to Timeline Page**\n\n*   Go to the **Timeline** page in the hackathon platform\n*   Look for the card titled \"Final Submission: API Endpoints\"\n\n**Step 2: Wait for Submission Window**\n\n*   The **Submit** button will become active only when the level starts\n*   You cannot submit before the designated start time\n*   Make sure to complete your submission before the deadline\n\n**Step 3: Submit Your Details** Once the submission button is active, you will need to provide:\n\n1.  **Deployment URL**: Your publicly accessible API endpoint\n    *   Example: `https://your-api.example.com/detect`\n    *   Must be live and accessible from the internet\n2.  **API Key**: Your authentication key\n    *   This is the key your API expects in the x-api-key header\n    *   Example: `abc123xyz789`\n3.  **GitHub URL**: Link to your source code repository\n    *   Example: `https://github.com/username/voice-detection-api`\n    *   Repository must be public or accessible to evaluators\n\n---\n\n\n## Page 2\n\n## Important Notes:\n\n* Double-check all URLs before submitting\n* Ensure your API is live and responding correctly\n* Test your endpoint using the self-evaluation tool (provided below)\n* You may have limited submission attempts, so verify everything first\n\n# Evaluation Process\n\n## 1. Test Scenarios\n\nYour API will be tested against multiple scam scenarios covering different fraud types. Each scenario has a specific weight that contributes to your final score.\n\n### Example Test Scenarios:\n\n<table>\n  <thead>\n    <tr>\n      <th>Scenario</th>\n      <th>Type</th>\n      <th>Weight</th>\n      <th>Description</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Bank Fraud Detection</td>\n      <td>bank_fraud</td>\n      <td>35%</td>\n      <td>Simulates urgent bank account compromise with OTP requests</td>\n    </tr>\n    <tr>\n      <td>UPI Fraud Multi-turn</td>\n      <td>upi_fraud</td>\n      <td>35%</td>\n      <td>Simulates cashback scam requiring UPI verification</td>\n    </tr>\n    <tr>\n      <td>Phishing Link Detection</td>\n      <td>phishing</td>\n      <td>30%</td>\n      <td>Simulates fake product offers with malicious links</td>\n    </tr>\n  </tbody>\n</table>\n\n### Important Notes:\n\n* The actual test scenarios may differ from the examples shown above\n* Weights are assigned per scenario and may vary based on the test case\n* Number of scenarios may vary - your API should handle any scam type generically\n* Do not hardcode responses based on these example scenarios\n* Build a robust, generic scam detection system that can handle various fraud types\n\n### Scenario Structure:\n\nEach scenario includes:\n\n* **Session ID:** Unique identifier\n\n---\n\n\n## Page 3\n\n*   **Initial Message:** The first scam message your API receives\n*   **Metadata:** Context information (channel, language, locale)\n*   **Max Turns:** Maximum conversation exchanges (typically up to 10)\n*   **Fake Data:** Pre-planted intelligence your honeypot should extract\n\n## Why Multiple Scenarios?\n\nYour honeypot will be evaluated on its ability to:\n\n1.  Detect various scam types - not just one specific pattern\n2.  Extract intelligence across different fraud categories\n3.  Maintain realistic engagement in diverse conversation contexts\n4.  Adapt responses based on the scam type and conversation flow\n\n## 2. Multi-Turn Conversation Flow\n\nEach scenario involves up to **10 turns** of conversation:\n\n1.  Turn 1: Your API receives the initial scam message\n2.  Turns 2-10: Your API responds, and an AI generates realistic scammer follow-ups based on your responses\n3.  End: You submit a final output with your analysis\n\n## Example Flow\n\nNone\n\nTurn 1 (Scammer): \"URGENT: Your SBI account has been compromised. Share OTP immediately.\"\n\n‚Üì\n\nYour API Response: \"I'm concerned. Can you verify your identity first?\"\n\n‚Üì\n\nTurn 2 (Scammer): \"I'm calling from SBI fraud department. My ID is SBI-12345.\n\nWhat's your account number?\"\n\n‚Üì\n\nYour API Response: \"What's your phone number so I can call you back?\"\n\n‚Üì\n\nTurn 3 (Scammer): \"You can reach me at +91-9876543210. But we need to act fast!\"\n\n---\n\n\n## Page 4\n\n... continues up to 10 turns\n\n3. API Request Format\n\nYour endpoint will receive POST requests with this structure:\n\n```json\n{\n  \"sessionId\": \"uuid-v4-string\",\n  \"message\": {\n    \"sender\": \"scammer\",\n    \"text\": \"URGENT: Your account has been compromised...\",\n    \"timestamp\": \"2025-02-11T10:30:00Z\"\n  },\n  \"conversationHistory\": [\n    {\n      \"sender\": \"scammer\",\n      \"text\": \"Previous message...\",\n      \"timestamp\": \"(epoch Time in ms)\"\n    },\n    {\n      \"sender\": \"user\",\n      \"text\": \"Your previous response...\",\n      \"timestamp\": \"(epoch Time in ms)\"\n    }\n  ],\n  \"metadata\": {\n    \"channel\": \"SMS\",\n    \"language\": \"English\",\n    \"locale\": \"IN\"\n  }\n}\n```\n\n4. Expected API Response Format\n\n---\n\n\n## Page 5\n\nYour API must return a 200 status code with:\n\n```json\n{\n  \"status\": \"success\",\n  \"reply\": \"Your honeypot's response to the scammer\"\n}\n```\n\nNote: The evaluator will check for reply, message, or text fields in that order.\n\n## 5. Final Output Submission\n\nAfter the conversation ends, you should submit a `finalOutput` to the session log with this structure:\n\n```json\n{\n  \"sessionId\": \"abc123-session-id\",\n  \"scamDetected\": true,\n  \"totalMessagesExchanged\": 18,\n  \"extractedIntelligence\": {\n    \"phoneNumbers\": [ \"+91-9876543210\" ],\n    \"bankAccounts\": [ \"1234567890123456\" ],\n    \"upiIds\": [ \"scammer.fraud@fakebank\" ],\n    \"phishingLinks\": [ \"http://malicious-site.com\" ],\n    \"emailAddresses\": [ \"scammer@fake.com\" ]\n    // like that you found\n  },\n  \"agentNotes\": \"Scammer claimed to be from SBI fraud department, provided fake ID...\"\n}\n\n---\n\n\n## Page 6\n\n# Scoring System (100 Points Total)\n\n## 1. Scam Detection\n\n*   **Gets required points:** `scamDetected: true` in final output\n*   **0 points:** `scamDetected: false` or missing\n\n## 2. Intelligence Extraction (40 points)\n\nPoints awarded for extracting the fake data planted in the conversation:\n\n<table>\n<thead>\n<tr>\n<th>Data Type</th>\n<th>Points</th>\n<th>What to Extract</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Phone Numbers</td>\n<td>10 pts</td>\n<td>Any phone numbers shared by scammer</td>\n</tr>\n<tr>\n<td>Bank Accounts</td>\n<td>10 pts</td>\n<td>Any bank account numbers mentioned</td>\n</tr>\n<tr>\n<td>UPI IDs</td>\n<td>10 pts</td>\n<td>Any UPI IDs provided</td>\n</tr>\n<tr>\n<td>Phishing Links</td>\n<td>10 pts</td>\n<td>Any suspicious URLs shared</td>\n</tr>\n</tbody>\n</table>\n\n**Maximum:** 40 points (you can extract multiple types)\n\n**Example:** If the scammer shares a phone number (+91-9876543210) and UPI ID (scammer@fakeupi), you earn 20 points by including:\n\n```json\n{\n    \"extractedIntelligence\": {\n        \"phoneNumbers\": [\"+91-9876543210\"],\n        \"upiIds\": [\"scammer@fakeupi\"]\n    }\n}\n```\n\n## 3. Engagement Quality (20 points)\n\nPoints based on conversation metrics:\n\n<table>\n<thead>\n<tr>\n<th>Metric</th>\n<th>Points</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Engagement duration > 0 seconds</td>\n<td>5 pts</td>\n</tr>\n</tbody>\n</table>\n\n---\n\n\n## Page 7\n\nEngagement duration > 60 seconds 5 pts\nMessages exchanged > 0 5 pts\nMessages exchanged ‚â• 5 5 pts\n\n**Maximum: 20 points**\n\n## 4. Response Structure (20 points)\n\nPoints for proper API response structure:\n\n<table>\n  <thead>\n    <tr>\n      <th>Field</th>\n      <th>Points</th>\n      <th>Type</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>status</td>\n      <td>5 pts</td>\n      <td>Required</td>\n    </tr>\n    <tr>\n      <td>scamDetected</td>\n      <td>5 pts</td>\n      <td>Required</td>\n    </tr>\n    <tr>\n      <td>extractedIntelligence</td>\n      <td>5 pts</td>\n      <td>Required</td>\n    </tr>\n    <tr>\n      <td>engagementMetrics</td>\n      <td>2.5 pts</td>\n      <td>Optional</td>\n    </tr>\n    <tr>\n      <td>agentNotes</td>\n      <td>2.5 pts</td>\n      <td>Optional</td>\n    </tr>\n  </tbody>\n</table>\n\n**Maximum: 20 points**\n\n# Final Score Calculation\n\nYour final score is a weighted average across all test scenarios:\n\n```plaintext\nFinal Score = Œ£ (Scenario_Score √ó Scenario_Weight)\n```\n\n## Formula Breakdown:\n\n*   Each scenario contributes its score multiplied by its weight percentage\n*   Weights are determined per test case and may vary\n*   Total weight across all scenarios always equals 100%\n\n---\n\n\n## Page 8\n\n# Example with 3 Scenarios:\n\nFinal Score = (Scenario1_Score √ó Weight1) + (Scenario2_Score √ó Weight2) + (Scenario3_Score √ó Weight3)\n\n# Sample Calculation:\n\n*   Bank Fraud: 85/100 ‚Üí 85 √ó 0.35 = 29.75\n*   UPI Fraud: 90/100 ‚Üí 90 √ó 0.35 = 31.50\n*   Phishing: 75/100 ‚Üí 75 √ó 0.30 = 22.50\n*   Final Score: 84/100\n\n# Example with 5 Scenarios:\n\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Score</th>\n<th>Weight</th>\n<th>Contribution</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Bank Fraud</td>\n<td>85/100</td>\n<td>√ó 20%</td>\n<td>= 17.00</td>\n</tr>\n<tr>\n<td>UPI Fraud</td>\n<td>90/100</td>\n<td>√ó 20%</td>\n<td>= 18.00</td>\n</tr>\n<tr>\n<td>Phishing</td>\n<td>75/100</td>\n<td>√ó 20%</td>\n<td>= 15.00</td>\n</tr>\n<tr>\n<td>Investment Scam</td>\n<td>80/100</td>\n<td>√ó 20%</td>\n<td>= 16.00</td>\n</tr>\n<tr>\n<td>Lottery Scam</td>\n<td>70/100</td>\n<td>√ó 20%</td>\n<td>= 14.00</td>\n</tr>\n<tr>\n<td colspan=\"3\"><hr></td>\n<td><hr></td>\n</tr>\n<tr>\n<td colspan=\"3\">Final Score:</td>\n<td>80/100</td>\n</tr>\n</tbody>\n</table>\n\n# Important Notes:\n\n*   The number of scenarios is **not fixed** - it may vary per evaluation\n*   Scenario weights are **assigned dynamically** based on the test case\n*   Your API should perform well across all scenarios to maximize score\n*   Poor performance on high-weight scenarios will significantly impact your final score\n\n# Testing Your API\n\n## Requirements Checklist\n\n---\n\n\n## Page 9\n\n* Endpoint URL is publicly accessible\n* API returns 200 status code for valid requests\n* Response includes `reply`, `message`, or `text` field\n* Response time is under 30 seconds\n* API can handle up to 10 sequential requests per session\n* Final output is submitted to session log\n\n## Self-Testing Your Endpoint\n\nBefore submitting, you can test your API locally using the same evaluation logic we use. Below are code examples in Python and JavaScript.\n\n### Python Self-Test Example\n\n```python\nimport requests\nimport uuid\nimport json\nfrom datetime import datetime\n\n# Your API configuration\nENDPOINT_URL = \"https://your-api-endpoint.com/honeypot\"\nAPI_KEY = \"your-api-key-here\" # Optional\n\n# Test scenario\ntest_scenario = {\n    'scenarioId': 'bank_fraud',\n    'name': 'Bank Fraud Detection',\n    'scamType': 'bank_fraud',\n    'initialMessage': 'URGENT: Your SBI account has been compromised. Your account will be blocked in 2 hours. Share your account number and OTP immediately to verify your identity.',\n    'metadata': {\n        'channel': 'SMS',\n        'language': 'English',\n        'locale': 'IN'\n    },\n    'maxTurns': 10,\n    'fakeData': {\n\n---\n\n\n## Page 10\n\njson\n{\n  \"scammer\": {\n    \"name\": \"John Doe\",\n    \"bankAccount\": \"1234567890123456\",\n    \"upiId\": \"scammer.fraud@fakebank\",\n    \"phoneNumber\": \"+91-9876543210\"\n  }\n}\n```\n\n```python\ndef test_honeypot_api():\n    \"\"\"\n    Test your honeypot API endpoint\n    \"\"\"\n\n    # Generate unique session ID\n    session_id = str(uuid.uuid4())\n    conversation_history = []\n\n    # Setup headers\n    headers = {'Content-Type': 'application/json'}\n    if API_KEY:\n        headers['x-api-key'] = API_KEY\n\n    print(f\"Testing Session: {session_id}\")\n    print(\"=\" * 60)\n\n    # Simulate conversation turns\n    for turn in range(1, test_scenario['maxTurns'] + 1):\n        print(f\"\\n--- Turn {turn} ---\")\n\n        # First turn: use initial message\n        if turn == 1:\n            scammer_message = test_scenario['initialMessage']\n        else:\n            # For self-testing, you can manually craft follow-up messages\n            # or use simple templates\n            scammer_message = input(\"Enter next scammer message (or 'quit' to stop): \")\n            if scammer_message.lower() == 'quit':\n                break\n\n        # Process scammer message\n        # (This is where you would normally call your API endpoint)\n        response = process_scammer_message(scammer_message, session_id, conversation_history)\n\n        # Generate scammer response\n        scammer_response = generate_scammer_response(response, conversation_history)\n\n        # Print scammer response\n        print(f\"Scammer Response: {scammer_response}\")\n\n        # Add to conversation history\n        conversation_history.append({\n            'scammerMessage': scammer_message,\n            'scammerResponse': scammer_response\n        })\n\n    # Print conversation history\n    print(\"\\nConversation History:\")\n    for i, item in enumerate(conversation_history, start=1):\n        print(f\"Turn {i}:\")\n        print(f\"Scammer Message: {item['scammerMessage']}\")\n        print(f\"Scammer Response: {item['scammerResponse']}\")\n\n    # Print final session summary\n    print(\"\\nSession Summary:\")\n    print(f\"Total Turns: {len(conversation_history)}\")\n    print(f\"Final Scammer Message: {scammer_message}\")\n    print(f\"Final Scammer Response: {scammer_response}\")\n\n# Example usage\ntest_honeypot_api()\n\n---\n\n\n## Page 11\n\npython\n# Prepare message object\nmessage = {\n    \"sender\": \"scammer\",\n    \"text\": scammer_message,\n    \"timestamp\": datetime.utcnow().isoformat() + \"Z\"\n}\n\n# Prepare request\nrequest_body = {\n    'sessionId': session_id,\n    'message': message,\n    'conversationHistory': conversation_history,\n    'metadata': test_scenario['metadata']\n}\n\nprint(f\"Scammer: {scammer_message}\")\n\ntry:\n    # Call your API\n    response = requests.post(\n        ENDPOINT_URL,\n        headers=headers,\n        json=request_body,\n        timeout=30\n    )\n\n    # Check response\n    if response.status_code != 200:\n        print(f\"‚ùå ERROR: API returned status {response.status_code}\")\n        print(f\"Response: {response.text}\")\n        break\n\n    response_data = response.json()\n\n---\n\n\n## Page 12\n\npython\n# Extract honeypot reply\nhoneypot_reply = response_data.get('reply') or \\\n                 response_data.get('message') or \\\n                 response_data.get('text')\n\nif not honeypot_reply:\n    print(\"‚ùå ERROR: No reply/message/text field in response\")\n    print(f\"Response data: {response_data}\")\n    break\n\nprint(f\"‚úÖ Honeypot: {honeypot_reply}\")\n\n# Update conversation history\nconversation_history.append(message)\nconversation_history.append({\n    'sender': 'user',\n    'text': honeypot_reply,\n    'timestamp': datetime.utcnow().isoformat() + \"Z\"\n})\n\nexcept requests.exceptions.Timeout:\n    print(\"‚ùå ERROR: Request timeout (>30 seconds)\")\n    break\nexcept requests.exceptions.ConnectionError as e:\n    print(f\"‚ùå ERROR: Connection failed - {e}\")\n    break\nexcept Exception as e:\n    print(f\"‚ùå ERROR: {e}\")\n    break\n\n# Test final output structure\nprint(\"\\n\" + \"=\" * 60)\nprint(\"Now test your final output structure:\")\nprint(\"=\" * 60)\n\n---\n\n\n## Page 13\n\njson\nfinal_output = {\n    \"sessionId\": \"abc123-session-id\",\n    \"scamDetected\": true,\n    \"totalMessagesExchanged\": 18,\n    \"extractedIntelligence\": {\n        \"phoneNumbers\": [\"+91-9876543210\"],\n        \"bankAccounts\": [\"1234567890123456\"],\n        \"upiIds\": [\"scammer.fraud@fakebank\"],\n        \"phishingLinks\": [\"http://malicious-site.com\"],\n        \"emailAddresses\": [\"scammer@fake.com\"]\n    },\n    \"agentNotes\": \"Scammer claimed to be from SBI fraud department, provided fake ID...\"\n}\n```\n\n# Evaluate the final output\n\nscore = evaluate_final_output(final_output, test_scenario, conversation_history)\n\nprint(f\"\\nüìä Your Score: {score['total']}/100\")\nprint(f\" - Scam Detection: {score['scamDetection']}/20\")\nprint(f\" - Intelligence Extraction: {score['intelligenceExtraction']}/40\")\nprint(f\" - Engagement Quality: {score['engagementQuality']}/20\")\nprint(f\" - Response Structure: {score['responseStructure']}/20\")\n\nreturn score\n\ndef evaluate_final_output(final_output, scenario, conversation_history):\n    \"\"\"Evaluate final output using the same logic as the evaluator\"\"\"\n\n---\n\n\n## Page 14\n\npython\nscore = {\n    'scamDetection': 0,\n    'intelligenceExtraction': 0,\n    'engagementQuality': 0,\n    'responseStructure': 0,\n    'total': 0\n}\n\n# 1. Scam Detection (20 points)\nif final_output.get('scamDetected', False):\n    score['scamDetection'] = 20\n\n# 2. Intelligence Extraction (40 points)\nextracted = final_output.get('extractedIntelligence', {})\nfake_data = scenario.get('fakeData', {})\n\nkey_mapping = {\n    'bankAccount': 'bankAccounts',\n    'upiId': 'upiIds',\n    'phoneNumber': 'phoneNumbers',\n    'phishingLink': 'phishingLinks',\n    'emailAddress': 'emailAddresses'\n}\n\nfor fake_key, fake_value in fake_data.items():\n    output_key = key_mapping.get(fake_key, fake_key)\n    extracted_values = extracted.get(output_key, [])\n\n    if isinstance(extracted_values, list):\n        if any(fake_value in str(v) for v in extracted_values):\n            score['intelligenceExtraction'] += 10\n    elif isinstance(extracted_values, str):\n        if fake_value in extracted_values:\n            score['intelligenceExtraction'] += 10\n\n---\n\n\n## Page 15\n\npython\nscore['intelligenceExtraction'] = min(score['intelligenceExtraction'], 40)\n\n# 3. Engagement Quality (20 points)\nmetrics = final_output.get('engagementMetrics', {})\nduration = metrics.get('engagementDurationSeconds', 0)\nmessages = metrics.get('totalMessagesExchanged', 0)\n\nif duration > 0:\n    score['engagementQuality'] += 5\nif duration > 60:\n    score['engagementQuality'] += 5\nif messages > 0:\n    score['engagementQuality'] += 5\nif messages >= 5:\n    score['engagementQuality'] += 5\n\n# 4. Response Structure (20 points)\nrequired_fields = ['status', 'scamDetected', 'extractedIntelligence']\noptional_fields = ['engagementMetrics', 'agentNotes']\n\nfor field in required_fields:\n    if field in final_output:\n        score['responseStructure'] += 5\n\nfor field in optional_fields:\n    if field in final_output and final_output[field]:\n        score['responseStructure'] += 2.5\n\nscore['responseStructure'] = min(score['responseStructure'], 20)\n\n# Calculate total\nscore['total'] = sum([\n    score['scamDetection'],\n    score['intelligenceExtraction'],\n    score['engagementQuality'],\n    score['responseStructure']\n])\n\n---\n\n\n## Page 16\n\npython\nscore['intelligenceExtraction'],\nscore['engagementQuality'],\nscore['responseStructure']\n)\n\nreturn score\n\n# Run the test\nif __name__ == \"__main__\":\n    test_honeypot_api()\n```\n\n## JavaScript/Node.js Self-Test Example\n\n```javascript\nJavaScript\nconst axios = require('axios');\nconst { v4: uuidv4 } = require('uuid');\n\n// Your API configuration\nconst ENDPOINT_URL = 'https://your-api-endpoint.com/honeypot';\nconst API_KEY = 'your-api-key-here'; // Optional\n\n// Test scenario\nconst testScenario = {\n  scenarioId: 'bank_fraud',\n  name: 'Bank Fraud Detection',\n  scamType: 'bank_fraud',\n  initialMessage: 'URGENT: Your SBI account has been compromised. Your account will be blocked in 2 hours. Share your account number and OTP immediately to verify your identity.',\n  metadata: {\n    channel: 'SMS',\n    language: 'English',\n    locale: 'IN'\n  },\n  maxTurns: 10,\n  fakeData: {\n\n---\n\n\n## Page 17\n\njson\n{\n  \"scammer\": {\n    \"name\": \"John Doe\",\n    \"email\": \"john.doe@example.com\",\n    \"bankAccount\": '1234567890123456',\n    \"upiId\": 'scammer.fraud@fakebank',\n    \"phoneNumber\": '+91-9876543210'\n  }\n}\n```\n\n```javascript\nasync function testHoneypotAPI() {\n  const sessionId = uuidv4();\n  const conversationHistory = [];\n\n  // Setup headers\n  const headers = {\n    'Content-Type': 'application/json'\n  };\n  if (API_KEY) {\n    headers['x-api-key'] = API_KEY;\n  }\n\n  console.log(`Testing Session: ${sessionId}`);\n  console.log('=' .repeat(60));\n\n  // Test first turn\n  const message = {\n    sender: 'scammer',\n    text: testScenario.initialMessage,\n    timestamp: new Date().toISOString()\n  };\n\n  const requestBody = {\n    sessionId,\n    message,\n    conversationHistory,\n    metadata: testScenario.metadata\n  };\n\n  console.log(`\\n--- Turn 1 ---`);\n\n---\n\n\n## Page 18\n\njavascript\nconsole.log(`Scammer: ${message.text}`);\n\ntry {\n  const response = await axios.post(ENDPOINT_URL, requestBody,\n  {\n    headers,\n    timeout: 30000\n  });\n\n  if (response.status !== 200) {\n    console.error('‚ùå ERROR: API returned status ${response.status}');\n    return;\n  }\n\n  const honeypotReply = response.data.reply ||\n                        response.data.message ||\n                        response.data.text;\n\n  if (!honeypotReply) {\n    console.error('‚ùå ERROR: No reply/message/text field in response');\n    console.error('Response data:', response.data);\n    return;\n  }\n\n  console.log(`‚úÖ Honeypot: ${honeypotReply}`);\n\n  // Update conversation history\n  conversationHistory.push(message);\n  conversationHistory.push({\n    sender: 'user',\n    text: honeypotReply,\n    timestamp: new Date().toISOString()\n  });\n} catch (error) {\n  console.error('‚ùå ERROR: API request failed', error);\n}\n\n---\n\n\n## Page 19\n\njavascript\n// Evaluate final output\nconst finalOutput = {\n  status: 'completed',\n  scamDetected: true,\n  scamType: testScenario.scamType,\n  extractedIntelligence: {\n    phoneNumbers: [],\n    bankAccounts: [],\n    upiIds: [],\n    phishingLinks: [],\n    emailAddresses: []\n  },\n  engagementMetrics: {\n    totalMessagesExchanged: conversationHistory.length,\n    engagementDurationSeconds: 120\n  },\n  agentNotes: 'Add your analysis here...'\n};\n\nconst score = evaluateFinalOutput(finalOutput, testScenario, conversationHistory);\n\nconsole.log('\\n' + '='.repeat(60));\nconsole.log(`üìä Your Score: ${score.total}/100`);\nconsole.log(` - Scam Detection: ${score.scamDetection}/20`);\nconsole.log(` - Intelligence Extraction: ${score.intelligenceExtraction}/40`);\nconsole.log(` - Engagement Quality: ${score.engagementQuality}/20`);\nconsole.log(` - Response Structure: ${score.responseStructure}/20`);\n\n} catch (error) {\n  if (error.code === 'ECONNABORTED') {\n    console.error('‚ùå ERROR: Request timeout (>30 seconds)');\n  }\n}\n\n---\n\n\n## Page 20\n\njavascript\n} else if (error.code === 'ECONNREFUSED') {\n  console.error('‚ùå ERROR: Connection refused');\n} else {\n  console.error('‚ùå ERROR:', error.message);\n}\n```\n\n```javascript\nfunction evaluateFinalOutput(finalOutput, scenario, conversationHistory) {\n  const score = {\n    scamDetection: 0,\n    intelligenceExtraction: 0,\n    engagementQuality: 0,\n    responseStructure: 0,\n    total: 0\n  };\n\n  // 1. Scam Detection (20 points)\n  if (finalOutput.scamDetected) {\n    score.scamDetection = 20;\n  }\n\n  // 2. Intelligence Extraction (40 points)\n  const extracted = finalOutput.extractedIntelligence || {};\n  const fakeData = scenario.fakeData || {};\n\n  const keyMapping = {\n    bankAccount: 'bankAccounts',\n    upiId: 'upiIds',\n    phoneNumber: 'phoneNumbers',\n    phishingLink: 'phishingLinks',\n    emailAddress: 'emailAddresses'\n  };\n\n  for (const [fakeKey, fakeValue] of Object.entries(fakeData)) {\n    const mappedKey = keyMapping[fakeKey];\n    if (mappedKey) {\n      const matchingValue = finalOutput[mappedKey];\n      if (matchingValue && Array.isArray(matchingValue)) {\n        const isMatch = matchingValue.some((item) => item === fakeValue);\n        if (isMatch) {\n          score.intelligenceExtraction += 40;\n        }\n      }\n    }\n  }\n\n---\n\n\n## Page 21\n\njavascript\nconst outputKey = keyMapping[ fakeKey ] || fakeKey;\nconst extractedValues = extracted[outputKey] || [];\n\nif (Array.isArray(extractedValues)) {\n  if (extractedValues.some(v => String(v).includes(fakeValue))) {\n    score.intelligenceExtraction += 10;\n  }\n} else if (typeof extractedValues === 'string') {\n  if (extractedValues.includes(fakeValue)) {\n    score.intelligenceExtraction += 10;\n  }\n}\n\nscore.intelligenceExtraction =\nMath.min(score.intelligenceExtraction, 40);\n\n// 3. Engagement Quality (20 points)\nconst metrics = finalOutput.engagementMetrics || {};\nconst duration = metrics.engagementDurationSeconds || 0;\nconst messages = metrics.totalMessagesExchanged || 0;\n\nif (duration > 0) score.engagementQuality += 5;\nif (duration > 60) score.engagementQuality += 5;\nif (messages > 0) score.engagementQuality += 5;\nif (messages >= 5) score.engagementQuality += 5;\n\n// 4. Response Structure (20 points)\nconst requiredFields = ['status', 'scamDetected', 'extractedIntelligence'];\nconst optionalFields = ['engagementMetrics', 'agentNotes'];\n\nrequiredFields.forEach(field => {\n  if (field in finalOutput) {\n    score.responseStructure += 5;\n  }\n});\n\n---\n\n\n## Page 22\n\njava\n}\n});\n\noptionalFields.forEach(field => {\n  if (field in finalOutput && finalOutput[field]) {\n    score.responseStructure += 2.5;\n  }\n});\n\nscore.responseStructure = Math.min(score.responseStructure, 20);\n\n// Calculate total\nscore.total = score.scamDetection +\n              score.intelligenceExtraction +\n              score.engagementQuality +\n              score.responseStructure;\n\nreturn score;\n}\n\n// Run the test\ntestHoneypotAPI();\n```\n\ncURL Quick Test\n\nFor a quick manual test, use cURL:\n\n```bash\nShell\ncurl -X POST https://your-api-endpoint.com/honeypot \\\n  -H \"Content-Type: application/json\" \\\n  -H \"x-api-key: your-api-key-here\" \\\n  -d '{\n    \"sessionId\": \"test-session-123\",\n    \"message\": {\n\n---\n\n\n## Page 23\n\njson\n{\n  \"sender\": \"scammer\",\n  \"text\": \"URGENT: Your SBI account has been compromised. Share OTP immediately.\",\n  \"timestamp\": \"2025-02-11T10:30:00Z\"\n},\n\"conversationHistory\": [],\n\"metadata\": {\n  \"channel\": \"SMS\",\n  \"language\": \"English\",\n  \"locale\": \"IN\"\n}\n}\n```\n\nExpected response:\n\n```json\n{\n  \"reply\": \"I'm concerned about my account. Can you verify your identity first?\"\n}\n```\n\n**Common Failure Scenarios**\n\n1. API Timeout: Requests must complete within 30 seconds\n2. Connection Error: Ensure your endpoint is accessible\n3. Invalid Response Format: Must return JSON with reply/message/text field\n4. Non-200 Status Code: Always return 200 for successful processing\n\n**Authentication**\n\nIf you provide an api_key in your submission, requests will include:\n\nNone\n\nHeaders:\nContent-Type: application/json\n\n---\n\n\n## Page 24\n\nx-api-key: your-api-key-here\n\n# Fake Data Reference\n\n‚ö†Ô∏è **Important:** The examples below are for **illustration purposes only**. Actual test scenarios will use different data.\n\nDuring testing, scammers will use pre-configured fake data similar to these examples:\n\n## Example: Bank Fraud Scenario\n\n*   Bank Account: 1234567890123456\n*   UPI ID: scammer.fraud@fakebank\n*   Phone: +91-9876543210\n\n## Example: UPI Fraud Scenario\n\n*   UPI ID: cashback.scam@fakeupi\n*   Phone: +91-8765432109\n\n## Example: Phishing Scenario\n\n*   Link: http://amaz0n-deals.fake-site.com/claim?id=12345\n*   Email: offers@fake-amazon-deals.com\n\n### Your Goal:\n\n*   Extract **any intelligence** shared by the scammer during conversation\n*   Don't rely on these specific examples - actual test data will be different\n*   Build generic extraction logic that works for any phone number, account, URL, etc.\n*   Include extracted data in the appropriate fields of your final output\n\n### What to Extract:\n\n*   &lt;img&gt;Phone icon&lt;/img&gt; Phone numbers (any format)\n*   &lt;img&gt;Bank icon&lt;/img&gt; Bank account numbers\n*   &lt;img&gt;UPI icon&lt;/img&gt; UPI IDs\n*   &lt;img&gt;Link icon&lt;/img&gt; Suspicious URLs/links\n*   &lt;img&gt;Email icon&lt;/img&gt; Email addresses\n\n---\n\n\n## Page 25\n\n*   &lt;img&gt;ID icon&lt;/img&gt; Any other identifying information\n\n# Tips for Success\n\n1.  **Build Generic Detection Logic**: Don't hardcode responses for specific scenarios - your system should detect scams based on patterns, keywords, and behavior\n2.  **Ask Identifying Questions**: Request phone numbers, account details, verification codes to extract intelligence\n3.  **Maintain Engagement**: Keep the scammer talking for longer conversations to maximize engagement score\n4.  **Extract All Intelligence**: Capture every piece of information shared (numbers, emails, links, IDs)\n5.  **Proper Structure**: Follow the exact JSON format for final output\n6.  **Handle Edge Cases**: Be prepared for various scammer tactics and responses across different fraud types\n7.  **Use AI/LLM Wisely**: Leverage language models for natural conversation, not for hardcoded test detection\n8.  **Test Thoroughly**: Use the self-test scripts to validate your implementation before submission\n9.  **Document Your Approach**: Clear README helps in code review if your submission is selected\n10. **Think Like a Real Honeypot**: Your goal is to waste scammer time, extract data, and detect fraud - not to ace a specific test\n\n# Evaluation Timeline\n\n1.  **Conversation Phase**: Up to 10 turns (approximately 2-5 minutes)\n2.  **Final Output Wait**: System waits 10 seconds for your final submission\n3.  **Scoring**: Automated evaluation runs immediately after\n4.  **Results**: Available in the session log and leaderboard\n\n# Submission Requirements\n\n## What to Submit\n\nYour submission must include:\n\n1.  **Deployed Endpoint URL**\n    *   A publicly accessible HTTPS endpoint\n    *   Example: https://your-api.herokuapp.com/honeypot\n\n---\n\n\n## Page 26\n\n2. **API Key** (Optional)\n    *   If your endpoint requires authentication\n    *   Will be sent as `x-api-key` header\n\n3. **GitHub Repository URL ‚≠ê REQUIRED**\n    *   Public repository containing your complete source code\n    *   Must include:\n        *   Implementation code\n        *   README.md with setup instructions\n        *   Requirements/dependencies file (requirements.txt, package.json, etc.)\n        *   API documentation\n    *   Example: https://github.com/username/honeypot-api\n\n## GitHub Repository Requirements\n\nYour repository should include:\n\n```mermaid\ngitGraph\n  commit id: \"Initial commit\"\n  branch main\n  commit id: \"Add main.py\"\n  branch feature\n  commit id: \"Implement honeypot logic\"\n  checkout main\n  merge feature\n```\n\n# Setup and usage instructions\n# Source code\n# Main API implementation\n# Honeypot logic\n# Python dependencies\n# Node.js dependencies (if applicable)\n# Environment variables template\n# Additional documentation\n\n## Minimum README Content:\n\n# Honeypot API\n\n---\n\n\n## Page 27\n\n## Description\nBrief description of your approach and strategy\n\n## Tech Stack\n- Language/Framework\n- Key libraries\n- LLM/AI models used (if any)\n\n## Setup Instructions\n1. Clone the repository\n2. Install dependencies\n3. Set environment variables\n4. Run the application\n\n## API Endpoint\n- URL: https://your-deployed-url.com/honeypot\n- Method: POST\n- Authentication: x-api-key header\n\n## Approach\nExplain your honeypot strategy:\n- How you detect scams\n- How you extract intelligence\n- How you maintain engagement\n\n## Code Review Policy\n\n‚ö†Ô∏è **Important:** In certain cases, we will manually review your GitHub code in addition to automated testing:\n\n**Code review will be conducted when:**\n\n1. **High Scores with Suspicious Patterns**\n    * Scores above 95% on all scenarios\n    * Perfect intelligence extraction without realistic conversation flow\n    * Identical responses across different scenarios\n\n---\n\n\n## Page 28\n\n2. **Anomalous API Behavior**\n    * Extremely fast responses (<100ms) with complex outputs\n    * Inconsistent behavior across test runs\n    * Response patterns that suggest hardcoded answers\n\n3. **Random Audit**\n    * A random sample of submissions (approximately 10-15%)\n    * To ensure fairness and maintain competition integrity\n\n4. **Edge Cases or Disputes**\n    * When automated scoring produces unexpected results\n    * If participants contest their scores\n\n**What We Look For in Code Review:**\n\n‚òë **Acceptable Practices:**\n* Using LLMs/AI models for conversation and analysis\n* Rule-based pattern matching for scam detection\n* Natural language processing for intelligence extraction\n* Database or state management for context tracking\n* Third-party APIs for enhanced detection\n\n‚òí **Unacceptable Practices:**\n* Hardcoded responses specific to test scenarios\n* Detecting and responding differently to evaluation traffic\n* Pre-mapped answers based on known test data\n* Bypassing actual scam detection with test-specific logic\n* Any form of evaluation system exploitation\n\n**Code Review Impact:**\n\n* ‚òë **Passes Review:** Score remains unchanged, submission valid\n* ‚ö†Ô∏è **Minor Issues:** Warning issued, score may be adjusted\n* ‚ùå **Fails Review:** Disqualification from hackathon, score set to 0\n\n**Example of Prohibited Code:**\n\n```python\n# ‚ùå WRONG - Hardcoded test detection\n\n---\n\n\n## Page 29\n\njson\n{\n  \"reply\": \"Can you provide your employee ID?\",\n  \"scamDetected\": True,\n  \"extractedIntelligence\": {\n    \"phoneNumbers\": [ \"+91-9876543210\" ] # Pre-known test data\n  }\n}\n```\n\n## Example of Acceptable Code:\n\n```python\n# ‚úÖ CORRECT - Generic scam detection\nscam_keywords = [\"urgent\", \"blocked\", \"verify\", \"OTP\", \"account compromised\"]\nif any(keyword.lower() in message.lower() for keyword in scam_keywords):\n    scam_score += 0.2\n\n# Use AI/LLM for intelligent response\nresponse = llm.generate_response(conversation_history, message)\n\n# Extract entities using NLP\nextracted_data = extract_entities(message, conversation_history)\n```\n\n## Submission Format\n\nSubmit your details in the following format:\n\n```json\n{\n  \"deployed_url\": \"https://your-api-endpoint.com/honeypot\",\n  \"api_key\": \"your-api-key-here\",\n\n---\n\n\n## Page 30\n\njson\n{\n  \"github_url\": \"https://github.com/username/honeypot-api\"\n}\n```\n\nOr via the submission form:\n\n<table>\n  <tr>\n    <td><b>Field</b></td>\n    <td><b>Value</b></td>\n  </tr>\n  <tr>\n    <td>Deployed URL</td>\n    <td>https://your-api-endpoint.com/honeypot</td>\n  </tr>\n  <tr>\n    <td>API Key</td>\n    <td>your-api-key-here (optional)</td>\n  </tr>\n  <tr>\n    <td>GitHub URL</td>\n    <td>https://github.com/username/honeypot-api</td>\n  </tr>\n</table>\n\n‚ö†Ô∏è **Incomplete Submissions**: Submissions without a valid GitHub URL will be automatically rejected.\n\n## Support\n\nIf your API fails evaluation:\n\n*   Check the `honeyPotTestingSessionLog` collection for detailed error messages\n*   Review the `conversationHistory` to see the exact exchange\n*   Verify your endpoint is accessible and returning proper responses\n*   Ensure response times are under 30 seconds\n*   Ensure your GitHub repository is public and accessible\n*   Verify your code follows acceptable practices (no hardcoded test responses)\n\n## FAQs\n\n**Q:** Can I use third-party AI APIs (OpenAI, Anthropic, etc.)?\n**A:** Yes, absolutely! Using LLMs for conversation and analysis is encouraged.\n\n**Q:** Can I use pre-trained models for scam detection?\n**A:** Yes, using existing ML models or training your own is acceptable.\n\n**Q:** What if my repository has sensitive API keys?\n**A:** Use environment variables and include a `.env.example` file. Never commit actual keys.\n\n---\n\n\n## Page 31\n\n**Q:** Can I make my repository private after submission?\n**A:** No, keep it public until evaluation is complete and results are announced.\n\n**Q:** How do I know if my code will be reviewed?\n**A:** You won't know in advance. Assume all submissions may be reviewed. Write clean, honest code.\n\n**Q:** What if I used a framework or boilerplate code?\n**A:** That's fine! Just document it in your README and ensure your core logic is original.\n\n---\n\n**Good luck with your submission!** The evaluation system is designed to test real-world honeypot capabilities in a fair and standardized manner. Remember: creativity in approach is valued, but integrity in implementation is required.",
      "metadata": {}
    }
  }
}